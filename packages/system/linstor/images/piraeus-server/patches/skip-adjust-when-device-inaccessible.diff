From 6a556821b9a0996d34389a27b941694ce810a44c Mon Sep 17 00:00:00 2001
From: Andrei Kvapil <kvapss@gmail.com>
Date: Mon, 12 Jan 2026 14:26:57 +0100
Subject: [PATCH 1/3] Fix: Skip DRBD adjust/res file regeneration when child
 layer device is inaccessible

When deleting encrypted (LUKS) resources, the LUKS layer may close its device
before the DRBD layer attempts to adjust the resource or regenerate the res
file. This causes 'Failed to adjust DRBD resource' errors.

This fix adds checks before regenerateResFile() and drbdUtils.adjust()
to verify that child layer devices are accessible. If a child device doesn't
exist or is not accessible (e.g., LUKS device is closed during resource
deletion), these operations are skipped and the adjustRequired flag is cleared,
allowing resource deletion to proceed successfully.

Co-Authored-By: Claude <noreply@anthropic.com>
Signed-off-by: Andrei Kvapil <kvapss@gmail.com>
---
 .../linbit/linstor/layer/drbd/DrbdLayer.java  | 72 ++++++++++++++++---
 1 file changed, 61 insertions(+), 11 deletions(-)

diff --git a/satellite/src/main/java/com/linbit/linstor/layer/drbd/DrbdLayer.java b/satellite/src/main/java/com/linbit/linstor/layer/drbd/DrbdLayer.java
index 01967a31f..871d830d1 100644
--- a/satellite/src/main/java/com/linbit/linstor/layer/drbd/DrbdLayer.java
+++ b/satellite/src/main/java/com/linbit/linstor/layer/drbd/DrbdLayer.java
@@ -592,7 +592,29 @@ public class DrbdLayer implements DeviceLayer
             // The .res file might not have been generated in the prepare method since it was
             // missing information from the child-layers. Now that we have processed them, we
             // need to make sure the .res file exists in all circumstances.
-            regenerateResFile(drbdRscData);
+            // However, if the underlying devices are not accessible (e.g., LUKS device is closed
+            // during resource deletion), we skip regenerating the res file to avoid errors
+            boolean canRegenerateResFile = true;
+            if (!skipDisk && !drbdRscData.getAbsResource().isDrbdDiskless(workerCtx))
+            {
+                AbsRscLayerObject<Resource> dataChild = drbdRscData.getChildBySuffix(RscLayerSuffixes.SUFFIX_DATA);
+                if (dataChild != null)
+                {
+                    for (DrbdVlmData<Resource> drbdVlmData : drbdRscData.getVlmLayerObjects().values())
+                    {
+                        VlmProviderObject<Resource> childVlm = dataChild.getVlmProviderObject(drbdVlmData.getVlmNr());
+                        if (childVlm == null || !childVlm.exists() || childVlm.getDevicePath() == null)
+                        {
+                            canRegenerateResFile = false;
+                            break;
+                        }
+                    }
+                }
+            }
+            if (canRegenerateResFile)
+            {
+                regenerateResFile(drbdRscData);
+            }
 
             // createMetaData needs rendered resFile
             for (DrbdVlmData<Resource> drbdVlmData : createMetaData)
@@ -766,19 +788,47 @@ public class DrbdLayer implements DeviceLayer
 
                 if (drbdRscData.isAdjustRequired())
                 {
-                    try
+                    // Check if underlying devices are accessible before adjusting
+                    // This is important for encrypted resources (LUKS) where the device
+                    // might be closed during deletion
+                    boolean canAdjust = true;
+                    if (!skipDisk && !drbdRscData.getAbsResource().isDrbdDiskless(workerCtx))
                     {
-                        drbdUtils.adjust(
-                            drbdRscData,
-                            false,
-                            skipDisk,
-                            false
-                        );
+                        AbsRscLayerObject<Resource> dataChild = drbdRscData.getChildBySuffix(RscLayerSuffixes.SUFFIX_DATA);
+                        if (dataChild != null)
+                        {
+                            for (DrbdVlmData<Resource> drbdVlmData : drbdRscData.getVlmLayerObjects().values())
+                            {
+                                VlmProviderObject<Resource> childVlm = dataChild.getVlmProviderObject(drbdVlmData.getVlmNr());
+                                if (childVlm == null || !childVlm.exists() || childVlm.getDevicePath() == null)
+                                {
+                                    canAdjust = false;
+                                    break;
+                                }
+                            }
+                        }
                     }
-                    catch (ExtCmdFailedException extCmdExc)
+
+                    if (canAdjust)
+                    {
+                        try
+                        {
+                            drbdUtils.adjust(
+                                drbdRscData,
+                                false,
+                                skipDisk,
+                                false
+                            );
+                        }
+                        catch (ExtCmdFailedException extCmdExc)
+                        {
+                            restoreBackupResFile(drbdRscData);
+                            throw extCmdExc;
+                        }
+                    }
+                    else
                     {
-                        restoreBackupResFile(drbdRscData);
-                        throw extCmdExc;
+                        drbdRscData.setAdjustRequired(false);
                     }
                 }
 
-- 
2.39.5 (Apple Git-154)


From afe51ea674c4a350c27d1f2cacfecf6fe42b8a7a Mon Sep 17 00:00:00 2001
From: Andrei Kvapil <kvapss@gmail.com>
Date: Mon, 12 Jan 2026 14:27:52 +0100
Subject: [PATCH 2/3] fix(satellite): skip lsblk when device path doesn't
 physically exist

Add physical device path existence check before calling lsblk in updateDiscGran().
This prevents race condition when drbdadm adjust temporarily brings devices down/up
and the kernel hasn't created the device node yet.

Issue: After satellite restart with patched code, some DRBD resources ended up in
Unknown state because:
1. drbdadm adjust successfully completes (brings devices up)
2. updateDiscGran() immediately tries to check discard granularity
3. /dev/drbd* device node doesn't exist yet (kernel hasn't created it)
4. lsblk fails with exit code 32 "not a block device"
5. StorageException interrupts DeviceManager cycle
6. DRBD device remains in incomplete state

Solution: Check Files.exists(devicePath) before calling lsblk. If device doesn't
exist yet, skip the check - it will be retried in the next DeviceManager cycle
when the device node is available.

Co-Authored-By: Claude <noreply@anthropic.com>
Signed-off-by: Andrei Kvapil <kvapss@gmail.com>
---
 .../linbit/linstor/core/devmgr/DeviceHandlerImpl.java    | 9 +++++++--
 1 file changed, 7 insertions(+), 2 deletions(-)

diff --git a/satellite/src/main/java/com/linbit/linstor/core/devmgr/DeviceHandlerImpl.java b/satellite/src/main/java/com/linbit/linstor/core/devmgr/DeviceHandlerImpl.java
index 49138a8fd..1c13cfc9d 100644
--- a/satellite/src/main/java/com/linbit/linstor/core/devmgr/DeviceHandlerImpl.java
+++ b/satellite/src/main/java/com/linbit/linstor/core/devmgr/DeviceHandlerImpl.java
@@ -68,6 +68,8 @@ import javax.inject.Inject;
 import javax.inject.Provider;
 import javax.inject.Singleton;
 
+import java.nio.file.Files;
+import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -1645,8 +1647,11 @@ public class DeviceHandlerImpl implements DeviceHandler
 
     private void updateDiscGran(VlmProviderObject<Resource> vlmData) throws DatabaseException, StorageException
     {
-        String devicePath = vlmData.getDevicePath();
-        if (devicePath != null && vlmData.exists())
+        @Nullable String devicePath = vlmData.getDevicePath();
+        // Check if device path physically exists before calling lsblk
+        // This is important for DRBD devices which might be temporarily unavailable during adjust
+        // (drbdadm adjust brings devices down/up, and kernel might not have created the device node yet)
+        if (devicePath != null && vlmData.exists() && Files.exists(Paths.get(devicePath)))
         {
             if (vlmData.getDiscGran() == VlmProviderObject.UNINITIALIZED_SIZE)
             {
-- 
2.39.5 (Apple Git-154)


From de1f22e7c008c5479f85a3b1ebdf8461944210f4 Mon Sep 17 00:00:00 2001
From: Andrei Kvapil <kvapss@gmail.com>
Date: Mon, 12 Jan 2026 14:28:23 +0100
Subject: [PATCH 3/3] fix(drbd): only check child devices when disk access is
 actually needed
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The previous implementation blocked `drbdadm adjust` whenever child
device paths were unavailable, even for operations that don't require
disk access (like network reconnect from StandAlone to Connected).

After node reboot, DRBD resources often remain in StandAlone state
because:
1. updateResourceToCurrentDrbdState() correctly detects StandAlone
   and sets adjustRequired=true
2. However, canAdjust check fails because child volumes may have
   devicePath=null (due to INACTIVE flag, cloning state, or
   initialization race)
3. adjust is skipped → adjustRequired=false → resources stay StandAlone

Root cause: The canAdjust check was added to protect LUKS deletion
scenarios but was applied to ALL cases, including network reconnect
which doesn't need disk access.

Fix: Check child device accessibility only when disk access is actually
required (volume creation, resize, metadata operations). Network
reconnect operations (StandAlone → Connected) now proceed without
checking child devices.

This ensures automatic DRBD reconnection after reboot while preserving
protection for LUKS deletion scenarios.

Co-Authored-By: Claude <noreply@anthropic.com>
Signed-off-by: Andrei Kvapil <kvapss@gmail.com>
---
 .../linbit/linstor/layer/drbd/DrbdLayer.java  | 27 ++++++++++++++++++-
 1 file changed, 26 insertions(+), 1 deletion(-)

diff --git a/satellite/src/main/java/com/linbit/linstor/layer/drbd/DrbdLayer.java b/satellite/src/main/java/com/linbit/linstor/layer/drbd/DrbdLayer.java
index 871d830d1..78b8195a4 100644
--- a/satellite/src/main/java/com/linbit/linstor/layer/drbd/DrbdLayer.java
+++ b/satellite/src/main/java/com/linbit/linstor/layer/drbd/DrbdLayer.java
@@ -792,7 +792,32 @@ public class DrbdLayer implements DeviceLayer
                     // This is important for encrypted resources (LUKS) where the device
                     // might be closed during deletion
                     boolean canAdjust = true;
-                    if (!skipDisk && !drbdRscData.getAbsResource().isDrbdDiskless(workerCtx))
+
+                    // IMPORTANT: Check child volumes only when disk access is actually needed.
+                    // For network reconnect (StandAlone -> Connected), disk access is not required.
+                    boolean needsDiskAccess = false;
+
+                    // Check if there are pending operations that require disk access
+                    for (DrbdVlmData<Resource> drbdVlmData : drbdRscData.getVlmLayerObjects().values())
+                    {
+                        Volume vlm = (Volume) drbdVlmData.getVolume();
+                        StateFlags<Volume.Flags> vlmFlags = vlm.getFlags();
+
+                        // Disk access is needed if:
+                        // - creating a new volume
+                        // - resizing
+                        // - checking/creating metadata
+                        if (!drbdVlmData.exists() ||
+                            drbdVlmData.checkMetaData() ||
+                            vlmFlags.isSomeSet(workerCtx, Volume.Flags.RESIZE, Volume.Flags.DRBD_RESIZE))
+                        {
+                            needsDiskAccess = true;
+                            break;
+                        }
+                    }
+
+                    // Check child volumes only if disk access is actually needed
+                    if (needsDiskAccess && !skipDisk && !drbdRscData.getAbsResource().isDrbdDiskless(workerCtx))
                     {
                         AbsRscLayerObject<Resource> dataChild = drbdRscData.getChildBySuffix(RscLayerSuffixes.SUFFIX_DATA);
                         if (dataChild != null)
-- 
2.39.5 (Apple Git-154)

