#!/bin/sh
# Migration 22 --> 23

set -euo pipefail

echo "Migrating HelmReleases: adding application labels and migrating from spec.chart to spec.chartRef"

# Process all HelmReleases with cozystack.io/ui=true label
kubectl get helmreleases --all-namespaces -o json -l cozystack.io/ui=true | \
  jq -r '.items[] | "\(.metadata.namespace)|\(.metadata.name)"' | \
  while IFS='|' read -r namespace name; do
    echo "Processing HelmRelease $namespace/$name"
    
    # Get the HelmRelease again to extract fields safely
    hr_json=$(kubectl get helmrelease -n "$namespace" "$name" -o json 2>/dev/null)
    if [ -z "$hr_json" ]; then
      echo "Skipping $namespace/$name: failed to get HelmRelease"
      continue
    fi
    
    # Extract chart name and sourceRef
    chart_name=$(printf '%s' "$hr_json" | jq -r '.spec.chart.spec.chart // empty')
    source_kind=$(printf '%s' "$hr_json" | jq -r '.spec.chart.spec.sourceRef.kind // empty')
    source_name=$(printf '%s' "$hr_json" | jq -r '.spec.chart.spec.sourceRef.name // empty')
    source_namespace=$(printf '%s' "$hr_json" | jq -r '.spec.chart.spec.sourceRef.namespace // empty')
    
    # Skip if already migrated or missing required fields
    if [ -z "$chart_name" ] || [ -z "$source_name" ] || [ "$source_kind" != "HelmRepository" ]; then
      echo "Skipping $namespace/$name: missing required fields or not using HelmRepository"
      continue
    fi
    
    # Skip cozystack-system repository
    if [ "$source_name" = "cozystack-system" ]; then
      echo "Skipping $namespace/$name: cozystack-system repository not supported for migration"
      continue
    fi
    
    # Determine bundle name from label or ownerReference
    bundle_name=$(printf '%s' "$hr_json" | jq -r '.metadata.labels["cozystack.io/bundle"] // empty')
    
    # If no label, try to get from ownerReferences
    if [ -z "$bundle_name" ]; then
      bundle_name=$(printf '%s' "$hr_json" | jq -r '.metadata.ownerReferences[]? | select(.kind == "CozystackBundle") | .name' | head -n 1)
    fi
    
    # Skip if no bundle found
    if [ -z "$bundle_name" ]; then
      echo "Skipping $namespace/$name: no bundle label or ownerReference found"
      continue
    fi
    
    # Determine artifact namespace (always cozy-system for ExternalArtifacts)
    artifact_namespace="cozy-system"
    
    # Build artifact name: bundle-name-package-name (new format)
    artifact_name="${bundle_name}-${chart_name}"
    
    echo "Migrating $namespace/$name: $chart_name -> $artifact_name (from $source_name)"
    
    # Check if already migrated (has chartRef with correct artifact name)
    current_chart_ref=$(printf '%s' "$hr_json" | jq -r '.spec.chartRef.name // empty')
    if [ "$current_chart_ref" = "$artifact_name" ]; then
      echo "Already migrated $namespace/$name, skipping"
      continue
    fi
    
    # Build JSON patch operations
    # Remove spec.chart if it exists
    # Add/replace spec.chartRef
    patch_ops="[]"
    has_chart=$(printf '%s' "$hr_json" | jq -e '.spec.chart != null' > /dev/null 2>&1 && echo "true" || echo "false")
    has_chart_ref=$(printf '%s' "$hr_json" | jq -e '.spec.chartRef != null' > /dev/null 2>&1 && echo "true" || echo "false")
    
    if [ "$has_chart" = "true" ]; then
      patch_ops=$(printf '%s' "$patch_ops" | jq ". + [{\"op\": \"remove\", \"path\": \"/spec/chart\"}]")
    fi
    
    if [ "$has_chart_ref" = "true" ]; then
      patch_ops=$(printf '%s' "$patch_ops" | jq ". + [{\"op\": \"replace\", \"path\": \"/spec/chartRef\", \"value\": {\"kind\": \"ExternalArtifact\", \"name\": \"$artifact_name\", \"namespace\": \"$artifact_namespace\"}}]")
    else
      patch_ops=$(printf '%s' "$patch_ops" | jq ". + [{\"op\": \"add\", \"path\": \"/spec/chartRef\", \"value\": {\"kind\": \"ExternalArtifact\", \"name\": \"$artifact_name\", \"namespace\": \"$artifact_namespace\"}}]")
    fi
    
    # Apply patch if there are operations to perform
    if printf '%s' "$patch_ops" | jq -e 'length > 0' > /dev/null 2>&1; then
      printf '%s' "$patch_ops" | kubectl patch helmrelease -n "$namespace" "$name" --type json --patch-file /dev/stdin
      echo "Migrated $namespace/$name"
    fi
    
    # Add application labels if missing
    # Get CozystackResourceDefinition to determine application kind and group
    app_kind=""
    app_group="apps.cozystack.io"
    app_name=""
    
    # Try to find CRD by chart or chartRef
    if [ -n "$chart_name" ] && [ -n "$source_name" ]; then
      # Try to find CRD by chart name and source
      crd_json=$(kubectl get cozystackresourcedefinitions -n cozy-system -o json 2>/dev/null | \
        jq -r --arg chart "$chart_name" --arg source "$source_name" \
        '.items[] | select((.spec.release.chart.name == $chart and .spec.release.chart.sourceRef.name == $source) or (.spec.release.chartRef.sourceRef.name == $chart)) | .' | head -n 1)
      
      if [ -n "$crd_json" ]; then
        app_kind=$(printf '%s' "$crd_json" | jq -r '.spec.application.kind // empty')
        prefix=$(printf '%s' "$crd_json" | jq -r '.spec.release.prefix // empty')
        
        # Extract application name from HelmRelease name by removing prefix
        if [ -n "$prefix" ] && [[ "$name" == "$prefix"* ]]; then
          app_name="${name#$prefix}"
        fi
      fi
    fi
    
    # If we couldn't determine from CRD, try to infer from HelmRelease name pattern
    if [ -z "$app_name" ]; then
      # Common prefixes to try
      for prefix in "mysql-" "postgres-" "redis-" "clickhouse-" "kafka-" "nats-" "rabbitmq-" "ferretdb-" "foundationdb-" \
                    "virtual-machine-" "vm-instance-" "vm-disk-" "virtualprivatecloud-" "bucket-" "kubernetes-" \
                    "http-cache-" "tcp-balancer-" "vpn-" "tenant-" "monitoring-" "ingress-" "info-" "etcd-" "seaweedfs-" "bootbox-"; do
        if [[ "$name" == "$prefix"* ]]; then
          app_name="${name#$prefix}"
          # Infer kind from prefix (capitalize and convert to CamelCase)
          kind_part=$(echo "$prefix" | sed 's/-$//' | sed 's/-\([a-z]\)/\U\1/g' | sed 's/^\([a-z]\)/\U\1/g')
          app_kind="$kind_part"
          break
        fi
      done
    fi
    
    # If still no app_name, use HelmRelease name as fallback
    if [ -z "$app_name" ]; then
      app_name="$name"
    fi
    
    # Add labels if we have the information
    if [ -n "$app_kind" ]; then
      label_patch_ops="[]"
      current_labels=$(printf '%s' "$hr_json" | jq -r '.metadata.labels // {}')
      
      # Check and add each label if missing
      if [ "$(printf '%s' "$current_labels" | jq -r '.["apps.cozystack.io/application.kind"] // empty')" != "$app_kind" ]; then
        label_patch_ops=$(printf '%s' "$label_patch_ops" | jq --arg kind "$app_kind" '. + [{"op": "add", "path": "/metadata/labels/apps.cozystack.io~1application.kind", "value": $kind}]')
      fi
      
      if [ "$(printf '%s' "$current_labels" | jq -r '.["apps.cozystack.io/application.group"] // empty")" != "$app_group" ]; then
        label_patch_ops=$(printf '%s' "$label_patch_ops" | jq --arg group "$app_group" '. + [{"op": "add", "path": "/metadata/labels/apps.cozystack.io~1application.group", "value": $group}]')
      fi
      
      if [ "$(printf '%s' "$current_labels" | jq -r '.["apps.cozystack.io/application.name"] // empty")" != "$app_name" ]; then
        label_patch_ops=$(printf '%s' "$label_patch_ops" | jq --arg name "$app_name" '. + [{"op": "add", "path": "/metadata/labels/apps.cozystack.io~1application.name", "value": $name}]')
      fi
      
      # Apply label patch if there are operations
      if printf '%s' "$label_patch_ops" | jq -e 'length > 0' > /dev/null 2>&1; then
        printf '%s' "$label_patch_ops" | kubectl patch helmrelease -n "$namespace" "$name" --type json --patch-file /dev/stdin
        echo "Added application labels to $namespace/$name (kind=$app_kind, group=$app_group, name=$app_name)"
      fi
    else
      echo "Warning: Could not determine application kind for $namespace/$name, skipping label addition"
    fi
  done

echo "Migration completed"

# Stamp version
kubectl create configmap -n cozy-system cozystack-version \
  --from-literal=version=23 --dry-run=client -o yaml | kubectl apply -f-

